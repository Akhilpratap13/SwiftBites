"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ms = require("ms");
const keygrip_1 = require("@authentication/keygrip");
const raw_cookie_1 = require("@authentication/raw-cookie");
const isSameOrigin_1 = require("./isSameOrigin");
const parseBaseURL_1 = require("./parseBaseURL");
var MaxAgeKind;
(function (MaxAgeKind) {
    MaxAgeKind["Session"] = "session";
})(MaxAgeKind = exports.MaxAgeKind || (exports.MaxAgeKind = {}));
var SameSitePolicy;
(function (SameSitePolicy) {
    /**
     * Ignore cookie if the request does not come from the current origin,
     * regardless of `req.method`.
     */
    SameSitePolicy["Strict"] = "strict";
    /**
     * Ignore cookie if the request does not come from the current origin,
     * unless the request is a `GET` request.
     */
    SameSitePolicy["Lax"] = "lax";
    /**
     * Allow the cookie from any domain.
     */
    SameSitePolicy["AnySite"] = "any-site";
})(SameSitePolicy = exports.SameSitePolicy || (exports.SameSitePolicy = {}));
var SigningPolicy;
(function (SigningPolicy) {
    /**
     * This is the default in production.  The cookie **must** be signed. If no
     * keys are provided and `SECURE_KEY` is empty, an error
     * will be thrown.
     *
     * If this option is selected, you can trust that any value in
     * a cookie was set by the server.
     */
    SigningPolicy[SigningPolicy["Required"] = 0] = "Required";
    /**
     * This can be used in libraries where you do not expect the
     * server to need to trust data sent in cookies, but you wish
     * to enable signing if the `SECURE_KEY` environment variable
     * is set.
     *
     * Note that if `SECURE_KEY` is not set, this is equivalent to
     * `Disabled`.
     */
    SigningPolicy[SigningPolicy["Optional"] = 1] = "Optional";
    /**
     * Use this if you know that you will not need to trust the data
     * stored in the cookie.  For example, you could use this for
     * something like a user preference for font-size.
     */
    SigningPolicy[SigningPolicy["Disabled"] = 2] = "Disabled";
})(SigningPolicy = exports.SigningPolicy || (exports.SigningPolicy = {}));
var EncryptionPolicy;
(function (EncryptionPolicy) {
    /**
     * This is the default in production. The cookie **must**
     * be encrypted. If no keys are provided and `SECURE_KEY`
     * is empty, an error will be thrown.
     *
     * If this option is selected, you can trust that any value in
     * a cookie will be kept secret
     */
    EncryptionPolicy[EncryptionPolicy["Required"] = 0] = "Required";
    /**
     * This can be used in libraries where you do not expect
     * secret data to be sent in cookies, but you wish
     * to enable encryption if the `SECURE_KEY` environment variable
     * is set.
     *
     * Note that if `SECURE_KEY` is not set, this is equivalent to
     * `Disabled`.
     */
    EncryptionPolicy[EncryptionPolicy["Optional"] = 1] = "Optional";
    /**
     * Use this if you know that you will not have secret data
     * stored in the cookie.  For example, you could use this for
     * something like a user preference for font-size.
     */
    EncryptionPolicy[EncryptionPolicy["Disabled"] = 2] = "Disabled";
})(EncryptionPolicy = exports.EncryptionPolicy || (exports.EncryptionPolicy = {}));
exports.Session = MaxAgeKind.Session;
class Cookie {
    constructor(name, options) {
        this._name = name;
        this._cacheSymbol = Symbol('Cookie Value Cache: ' + name);
        // signing
        const SECURE_KEY = process.env.SECURE_KEY;
        const keys = options.keys ? options.keys : SECURE_KEY ? SECURE_KEY.split(',') : undefined;
        if (keys && !(Array.isArray(keys) && keys.every(k => typeof k === 'string'))) {
            throw new Error('If provided, options.keys must be an array of strings.');
        }
        let signed = true;
        let encrypted = true;
        switch (options.encryptionPolicy) {
            case EncryptionPolicy.Disabled:
                encrypted = false;
                break;
            case EncryptionPolicy.Optional:
                encrypted = !!keys;
                break;
            default:
                if (options.encryptionPolicy === undefined && process.env.NODE_ENV === 'development') {
                    encrypted = !!keys;
                } else {
                    encrypted = true;
                }
                break;
        }
        switch (options.signingPolicy) {
            case SigningPolicy.Disabled:
                signed = false;
                if (encrypted) {
                    throw new Error('Enabling encryption implicitly enables signing. If you want to disable both, you must pass {encryptionPolicy: EncryptionPolicy.Disabled, signingPolicy: SigningPolicy.Disabled}');
                }
                break;
            case SigningPolicy.Optional:
                signed = !!keys;
                break;
            default:
                if (options.signingPolicy === undefined && process.env.NODE_ENV === 'development') {
                    signed = !!keys;
                } else {
                    signed = true;
                }
                break;
        }
        if ((signed || encrypted) && !keys) {
            throw new Error('You must either pass in `keys` as an option or set the `SECURE_KEY` environment variable to use signed or encrypted cookies.');
        }
        if (encrypted) {
            this._keygrip = new keygrip_1.KeygripSecret(keys);
        } else if (signed) {
            this._keygrip = new keygrip_1.KeygripPublic(keys);
        } else {
            this._keygrip = new keygrip_1.KeygripPassThrough();
        }
        // max age
        const maxAgeMilliseconds = options.maxAge === exports.Session ? undefined : typeof options.maxAge === 'string' ? ms(options.maxAge) : options.maxAge;
        if (maxAgeMilliseconds !== undefined && (typeof maxAgeMilliseconds !== 'number' || maxAgeMilliseconds !== Math.round(maxAgeMilliseconds) || maxAgeMilliseconds >= Number.MAX_SAFE_INTEGER || Number.isNaN(maxAgeMilliseconds))) {
            throw new Error('options.maxAge must be an integer or a number understood by the ms library. ' + (JSON.stringify(options.maxAge) || 'undefined') + ' is not a valid number of milliseconds.');
        }
        // same site
        const sameSitePolicy = options.sameSitePolicy || SameSitePolicy.Lax;
        if (typeof sameSitePolicy === 'object') {
            const writePolicy = sameSitePolicy.write.toLowerCase();
            if (writePolicy !== SameSitePolicy.AnySite && writePolicy !== SameSitePolicy.Lax && writePolicy !== SameSitePolicy.Strict) {
                throw new Error('Invalid write same site policy, should be Strict, Lax or AnySite');
            }
            const readPolicy = sameSitePolicy.read.toLowerCase();
            if (readPolicy !== SameSitePolicy.AnySite && readPolicy !== SameSitePolicy.Lax && readPolicy !== SameSitePolicy.Strict) {
                throw new Error('Invalid read same site policy, should be Strict, Lax or AnySite');
            }
            this._writeSameSitePolicy = writePolicy;
            this._readSameSitePolicy = readPolicy;
        } else {
            const policy = sameSitePolicy.toLowerCase();
            if (policy !== SameSitePolicy.AnySite && policy !== SameSitePolicy.Lax && policy !== SameSitePolicy.Strict) {
                throw new Error('Invalid same site policy, should be Strict, Lax or AnySite');
            }
            this._writeSameSitePolicy = policy;
            this._readSameSitePolicy = policy;
        }
        this._baseURL = parseBaseURL_1.default(options.baseURL);
        this._rawOptions = {
            domain: options.domain || undefined,
            serverSideOnly: options.serverSideOnly !== false,
            maxAgeMilliseconds,
            overwrite: options.overwrite !== false,
            path: options.path || '/',
            sameSite: this._readSameSitePolicy === SameSitePolicy.AnySite ? false : this._readSameSitePolicy
        };
    }
    _checkCSRF(req, method) {
        const sameSitePolicy = method === 'get' ? this._readSameSitePolicy : this._writeSameSitePolicy;
        if (sameSitePolicy === SameSitePolicy.AnySite) {
            return true;
        }
        if (req.method === 'GET' && sameSitePolicy === SameSitePolicy.Lax) {
            return true;
        }
        if (!isSameOrigin_1.default(req, this._baseURL)) {
            console.warn('CSRF check failed. Refusing to ' + method + ' the cookie, ' + this._name + ', because the request did not match the expected origin.');
            return false;
        }
        return true;
    }
    get(req, res) {
        if (!this._checkCSRF(req, 'get')) {
            return null;
        }
        if (req[this._cacheSymbol]) {
            return req[this._cacheSymbol].value;
        }
        const ciphertext = raw_cookie_1.getCookie(req, res, this._name);
        const result = ciphertext ? this._keygrip.unpackString(ciphertext) : null;
        try {
            if (result) {
                if (result.outdated) {
                    raw_cookie_1.setCookie(req, res, this._name, this._keygrip.packString(result.payload), this._rawOptions);
                }
                const value = JSON.parse(result.payload);
                req[this._cacheSymbol] = { value };
                return value;
            }
        } catch (ex) {}
        req[this._cacheSymbol] = { value: null };
        return null;
    }
    set(req, res, value) {
        if (!this._checkCSRF(req, 'set')) {
            return;
        }
        const str = JSON.stringify(value);
        const ciphertext = this._keygrip.packString(str);
        raw_cookie_1.setCookie(req, res, this._name, ciphertext, this._rawOptions);
        req[this._cacheSymbol] = { value };
    }
    remove(req, res) {
        if (!this._checkCSRF(req, 'set')) {
            return;
        }
        raw_cookie_1.removeCookie(req, res, this._name, this._rawOptions);
        req[this._cacheSymbol] = { value: null };
    }
    refresh(req, res, next) {
        const ciphertext = raw_cookie_1.getCookie(req, res, this._name);
        if (ciphertext) {
            const result = this._keygrip.unpackString(ciphertext);
            if (result) {
                raw_cookie_1.setCookie(req, res, this._name, result.outdated ? this._keygrip.packString(result.payload) : ciphertext, this._rawOptions);
            } else {
                raw_cookie_1.removeCookie(req, res, this._name, this._rawOptions);
            }
        }
        if (next) {
            next();
        }
    }
}
Cookie.MaxAgeKind = MaxAgeKind;
Cookie.SameSitePolicy = SameSitePolicy;
Cookie.Session = MaxAgeKind.Session;
Cookie.SigningPolicy = SigningPolicy;
Cookie.EncryptionPolicy = EncryptionPolicy;
exports.default = Cookie;
module.exports = Cookie;
module.exports.default = Cookie;
//# sourceMappingURL=index.js.map