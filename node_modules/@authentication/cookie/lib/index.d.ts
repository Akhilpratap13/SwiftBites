/// <reference types="node" />
import { URL } from 'url';
import { IncomingMessage, ServerResponse } from 'http';
export declare enum MaxAgeKind {
    Session = "session"
}
export declare enum SameSitePolicy {
    /**
     * Ignore cookie if the request does not come from the current origin,
     * regardless of `req.method`.
     */
    Strict = "strict",
    /**
     * Ignore cookie if the request does not come from the current origin,
     * unless the request is a `GET` request.
     */
    Lax = "lax",
    /**
     * Allow the cookie from any domain.
     */
    AnySite = "any-site"
}
export declare enum SigningPolicy {
    /**
     * This is the default in production.  The cookie **must** be signed. If no
     * keys are provided and `SECURE_KEY` is empty, an error
     * will be thrown.
     *
     * If this option is selected, you can trust that any value in
     * a cookie was set by the server.
     */
    Required = 0,
    /**
     * This can be used in libraries where you do not expect the
     * server to need to trust data sent in cookies, but you wish
     * to enable signing if the `SECURE_KEY` environment variable
     * is set.
     *
     * Note that if `SECURE_KEY` is not set, this is equivalent to
     * `Disabled`.
     */
    Optional = 1,
    /**
     * Use this if you know that you will not need to trust the data
     * stored in the cookie.  For example, you could use this for
     * something like a user preference for font-size.
     */
    Disabled = 2
}
export declare enum EncryptionPolicy {
    /**
     * This is the default in production. The cookie **must**
     * be encrypted. If no keys are provided and `SECURE_KEY`
     * is empty, an error will be thrown.
     *
     * If this option is selected, you can trust that any value in
     * a cookie will be kept secret
     */
    Required = 0,
    /**
     * This can be used in libraries where you do not expect
     * secret data to be sent in cookies, but you wish
     * to enable encryption if the `SECURE_KEY` environment variable
     * is set.
     *
     * Note that if `SECURE_KEY` is not set, this is equivalent to
     * `Disabled`.
     */
    Optional = 1,
    /**
     * Use this if you know that you will not have secret data
     * stored in the cookie.  For example, you could use this for
     * something like a user preference for font-size.
     */
    Disabled = 2
}
export interface Options {
    /**
     * A base url used to check the sameSitePolicy.  If this is not set, we
     * will attempt to infer the baseURL from the request's headers.
     */
    baseURL?: string | URL;
    /**
     * a string indicating the domain of the cookie (no default).
     */
    domain?: string;
    /**
     * a boolean indicating whether the cookie is only to be sent over HTTP(S),
     * and not made available to client JavaScript (true by default).
     */
    serverSideOnly?: boolean;
    keys?: string[];
    /**
     * a number representing the milliseconds from Date.now() for expiry or
     * a string to be parsed by the `ms` library.
     *
     * Set this to `Cookie.Session` to expire at the end of the current browser
     * session.
     */
    maxAge: MaxAgeKind.Session | number | string;
    /**
     * a boolean indicating whether to overwrite previously set
     * cookies of the same name (true by default). If this is true,
     * all cookies set during the same request with the same
     * name (regardless of path or domain) are filtered out of
     * the Set-Cookie header when setting this cookie.
     */
    overwrite?: boolean;
    /**
     * a string indicating the path of the cookie (/ by default).
     */
    path?: string;
    /**
     * This prevents CSRF by only allowing cookies for requests from the same
     * site.  This defaults to `lax` which is what you typically want for
     * authentication cookies, but you can also set it to `Strict` to prevent
     * sending cross site cookies even with get requests, or `AnySite` to allow
     * requests from any site.
     */
    sameSitePolicy?: SameSitePolicy | {
        read: SameSitePolicy;
        write: SameSitePolicy;
    };
    /**
     * a boolean indicating whether the cookie is only to be sent
     * over HTTPS (false by default for HTTP, true by default for HTTPS).
     *
     * You don't normally need to set this.
     */
    httpsOnly?: boolean;
    signingPolicy?: SigningPolicy;
    encryptionPolicy?: EncryptionPolicy;
}
export declare const Session: MaxAgeKind.Session;
export default class Cookie<T> {
    static readonly MaxAgeKind: typeof MaxAgeKind;
    static readonly SameSitePolicy: typeof SameSitePolicy;
    static readonly Session: MaxAgeKind.Session;
    static readonly SigningPolicy: typeof SigningPolicy;
    static readonly EncryptionPolicy: typeof EncryptionPolicy;
    private readonly _name;
    private readonly _writeSameSitePolicy;
    private readonly _readSameSitePolicy;
    private readonly _baseURL;
    private readonly _cacheSymbol;
    private readonly _rawOptions;
    private readonly _keygrip;
    constructor(name: string, options: Options);
    private _checkCSRF;
    get(req: IncomingMessage, res: ServerResponse): T | null;
    set(req: IncomingMessage, res: ServerResponse, value: T): void;
    remove(req: IncomingMessage, res: ServerResponse): void;
    refresh(req: IncomingMessage, res: ServerResponse, next?: () => any): void;
}
