/// <reference types="node" />
/// <reference types="express" />
import { Agent, ClientResponse } from 'http';
import { URL } from 'url';
import { Request, Response, NextFunction } from 'express';
import { Mixed } from '@authentication/types';
import AuthorizationError from './errors/AuthorizationError';
import StateVerificationFailure from './errors/StateVerificationFailure';
import TokenError from './errors/TokenError';
import InternalOAuthError from './errors/InternalOAuthError';
export interface Options {
    clientID: string;
    clientSecret: string;
    /**
     * Optionally provide keys to sign the cookie used to store "state"
     */
    cookieKeys?: string[];
    /**
     * Optionally override the default name for the cookie used to store "state"
     *
     * default: "authentication_oauth2"
     */
    cookieName?: string;
    authorizeURL: string | URL;
    accessTokenURL: string | URL;
    customHeaders?: {
        [key: string]: string;
    };
    /**
     * This 'hack' method is required for sites that don't use
     * 'access_token' as the name of the access token (for requests).
     * ( http://tools.ietf.org/html/draft-ietf-oauth-v2-16#section-7 )
     * it isn't clear what the correct value should be atm, so allowing
     * for specific (temporary?) override for now.
     *
     * default: 'access_token'
     */
    accessTokenName?: string;
    /**
     * Allows you to set an agent to use instead of the default HTTP or
     * HTTPS agents. Useful when dealing with your own certificates.
     */
    agent?: Agent | boolean;
    /**
     * Sets the authorization method for Authorization header.
     * e.g. Authorization: Bearer <token>  # "Bearer" is the authorization method.
     */
    authMethod?: string;
    /**
     * If you use the OAuth2 exposed 'get' method (and don't construct your own _request call )
     * this will specify whether to use an 'Authorize' header instead of passing the access_token as a query parameter
     */
    useAuthorizationHeaderForGET?: boolean;
    sessionKey?: string;
    scopeSeparator?: string;
    callbackURL: string | URL;
    trustProxy?: boolean;
}
export interface InitOptions<T> {
    params?: {
        [key: string]: string;
    };
    scope?: string | ReadonlyArray<string>;
    state?: T;
}
export interface CallbackOptions {
    params?: {
        [key: string]: string;
    };
}
export { TokenError };
export interface AccessTokenData<Results> {
    accessToken: string;
    refreshToken?: string;
    results: Results;
}
export default class OAuth2Authentication<State = Mixed, Results = Mixed> {
    private readonly _base;
    private readonly _authorizeURL;
    private readonly _accessTokenURL;
    private readonly _clientID;
    private readonly _scopeSeparator;
    private readonly _callbackURL;
    readonly callbackPath: string;
    private readonly _trustProxy;
    private readonly _cookie;
    constructor(options: Options);
    /**
     * Build the authorization header. In particular, build the part after the colon.
     * e.g. Authorization: Bearer <token>  # Build "Bearer <token>"
     */
    buildAuthHeader(token: string): string;
    getAuthorizeUrl(params?: {
        [key: string]: string;
    }): string;
    getOAuthAccessToken(code: string, params?: {
        [key: string]: string;
    }): Promise<AccessTokenData<Results>>;
    get(url: URL, accessToken: string): Promise<{
        data: string;
        response: ClientResponse;
    }>;
    isCallbackRequest(req: Request): boolean;
    userCancelledLogin(req: Request): boolean;
    private getCallbackURL(req);
    /**
     * Begin authentication by getting the URL to redirect the user to on the OAuth 2.0 service provider
     */
    private _redirectToProvider(req, res, options?);
    /**
     * Begin authentication by getting the URL to redirect the user to on the OAuth 2.0 service provider
     */
    redirectToProvider(req: Request, res: Response, next: NextFunction, options?: InitOptions<State>): void;
    /**
     * Complete authentication by processing the response from the OAuth 2.0 service provider to
     * get the accessToken and refreshToken. These can then be used to fetch a profile.
     */
    completeAuthentication(req: Request, res: Response, options?: CallbackOptions): Promise<{
        accessToken: string;
        refreshToken?: string;
        results: Results;
        state?: State;
    }>;
    static AuthorizationError: typeof AuthorizationError;
    static InternalOAuthError: typeof InternalOAuthError;
    static StateVerificationFailure: typeof StateVerificationFailure;
    static TokenError: typeof TokenError;
}
