"use strict";

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const cookie_1 = require("@authentication/cookie");
const AuthorizationError_1 = require("./errors/AuthorizationError");
const StateVerificationFailure_1 = require("./errors/StateVerificationFailure");
const TokenError_1 = require("./errors/TokenError");
exports.TokenError = TokenError_1.default;
const InternalOAuthError_1 = require("./errors/InternalOAuthError");
const getUID_1 = require("./getUID");
const originalURL_1 = require("./originalURL");
const OAuth2Base = require('oauth').OAuth2;
function resolveURL(path) {
    return typeof path === 'string' ? new url_1.URL(path) : path;
}
/**
 * Parse error response from OAuth 2.0 endpoint.
 *
 * OAuth 2.0-based authentication strategies can overrride this function in
 * order to parse error responses received from the token endpoint, allowing the
 * most informative message to be displayed.
 *
 * If this function is not overridden, the body will be parsed in accordance
 * with RFC 6749, section 5.2.
 */
function parseErrorResponse(body, status) {
    const json = JSON.parse(body);
    if (json.error) {
        return new TokenError_1.default(json.error, json.error_description, json.error_uri, status);
    }
    return null;
}
class OAuth2Authentication {
    constructor(options) {
        this._authorizeURL = resolveURL(options.authorizeURL);
        this._accessTokenURL = resolveURL(options.accessTokenURL);
        this._clientID = options.clientID;
        this._base = new OAuth2Base(options.clientID, options.clientSecret, '', this._authorizeURL.href, this._accessTokenURL.href, options.customHeaders);
        if (options.accessTokenName !== undefined) {
            this._base.setAccessTokenName(options.accessTokenName);
        }
        if (options.agent !== undefined) {
            this._base.setAgent(options.agent);
        }
        if (options.authMethod !== undefined) {
            this._base.setAuthMethod(options.authMethod);
        }
        if (options.useAuthorizationHeaderForGET !== undefined) {
            this._base.useAuthorizationHeaderforGET(options.useAuthorizationHeaderForGET);
        }
        this._scopeSeparator = options.scopeSeparator || ' ';
        this._callbackURL = options.callbackURL;
        this.callbackPath = (typeof options.callbackURL === 'string' ? new url_1.URL(options.callbackURL, 'http://example.com') : options.callbackURL).pathname;
        this._trustProxy = options.trustProxy;
        this._cookie = new cookie_1.default(options.cookieName || 'authentication_oauth2', {
            keys: options.cookieKeys,
            maxAge: cookie_1.default.Session,
            sameSitePolicy: cookie_1.default.SameSitePolicy.AnySite,
            encryptionPolicy: cookie_1.default.EncryptionPolicy.Optional,
            signingPolicy: cookie_1.default.SigningPolicy.Optional
        });
    }
    /**
     * Build the authorization header. In particular, build the part after the colon.
     * e.g. Authorization: Bearer <token>  # Build "Bearer <token>"
     */
    buildAuthHeader(token) {
        return this._base.buildAuthHeader(token);
    }
    getAuthorizeUrl(params) {
        return this._base.getAuthorizeUrl(params ? Object.assign({}, params) : params);
    }
    getOAuthAccessToken(code, params) {
        return new Promise((resolve, reject) => {
            this._base.getOAuthAccessToken(code, params ? Object.assign({}, params) : {}, (err, accessToken, refreshToken, results) => {
                const params = results;
                if (err) {
                    if (err.statusCode && err.data) {
                        try {
                            const e = parseErrorResponse(err.data, err.statusCode);
                            if (e) {
                                return reject(e);
                            }
                        } catch (_) {}
                    }
                    reject(new InternalOAuthError_1.default('Failed to obtain access token', err));
                } else if (!accessToken) {
                    // NOTE: GitHub returns an HTTP 200 OK on error responses.  As a result, the
                    //       underlying `oauth` implementation understandably does not parse the
                    //       response as an error.  This code swizzles the implementation to
                    //       handle this condition.
                    if (params.error) {
                        return reject(new TokenError_1.default(params.error, params.error_description, params.error_uri, 400));
                    }
                    reject(new InternalOAuthError_1.default('Failed to obtain access token'));
                } else {
                    resolve({
                        accessToken,
                        refreshToken,
                        results
                    });
                }
            });
        });
    }
    get(url, accessToken) {
        return new Promise((resolve, reject) => {
            this._base.get(url.href, accessToken, (err, data, response) => {
                if (err) {
                    reject(err);
                } else {
                    resolve({ data, response });
                }
            });
        });
    }
    isCallbackRequest(req) {
        return !!(req.query && (req.query.error || req.query.code));
    }
    userCancelledLogin(req) {
        return req.query && req.query.error === 'access_denied';
    }
    getCallbackURL(req) {
        return typeof this._callbackURL === 'string' ? new url_1.URL(this._callbackURL, originalURL_1.default(req, { trustProxy: this._trustProxy })) : this._callbackURL;
    }
    /**
     * Begin authentication by getting the URL to redirect the user to on the OAuth 2.0 service provider
     */
    _redirectToProvider(req, res, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const callbackURL = this.getCallbackURL(req);
            const authorizeUrl = new url_1.URL(this._authorizeURL.href);
            const p = options.params;
            if (p) {
                Object.keys(p).forEach(key => {
                    authorizeUrl.searchParams.set(key, p[key]);
                });
            }
            authorizeUrl.searchParams.set('response_type', 'code');
            if (callbackURL) {
                authorizeUrl.searchParams.set('redirect_uri', callbackURL.href);
            }
            const scope = options.scope;
            if (scope) {
                authorizeUrl.searchParams.set('scope', typeof scope === 'string' ? scope : scope.join(this._scopeSeparator));
            }
            authorizeUrl.searchParams.set('client_id', this._clientID);
            const stateID = yield getUID_1.default(24);
            authorizeUrl.searchParams.set('state', stateID);
            this._cookie.set(req, res, { k: stateID, d: options.state });
            res.redirect(authorizeUrl.href);
        });
    }
    /**
     * Begin authentication by getting the URL to redirect the user to on the OAuth 2.0 service provider
     */
    redirectToProvider(req, res, next, options = {}) {
        this._redirectToProvider(req, res, options).catch(next);
    }
    /**
     * Complete authentication by processing the response from the OAuth 2.0 service provider to
     * get the accessToken and refreshToken. These can then be used to fetch a profile.
     */
    completeAuthentication(req, res, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (req.query && req.query.error) {
                throw new AuthorizationError_1.default(req.query.error, req.query.error_description || (req.query.error === 'access_denied' ? 'Sign in cancelled' : req.query.error), req.query.error_uri);
            }
            if (!(req.query && req.query.code)) {
                throw new AuthorizationError_1.default('MISSING_CODE', 'The request is missing the "code" query string parameter.', undefined);
            }
            const callbackURL = this.getCallbackURL(req);
            const cookie = this._cookie.get(req, res);
            if (!cookie) {
                throw new StateVerificationFailure_1.default('The cookie used to verify state in the oauth transaction was not set.');
            }
            const { k: stateID, d: state } = cookie;
            if (stateID !== (req.query && req.query.state)) {
                throw new StateVerificationFailure_1.default('The oauth provider did not provide a valid "state" parameter in the response.');
            }
            var code = req.query.code;
            const params = options.params ? Object.assign({}, options.params) : {};
            params.grant_type = 'authorization_code';
            if (callbackURL) {
                params.redirect_uri = callbackURL.href;
            }
            const { accessToken, refreshToken, results } = yield this.getOAuthAccessToken(code, params);
            // it's up to the consumer to then load the profile
            return {
                accessToken,
                refreshToken,
                results,
                state
            };
        });
    }
}
OAuth2Authentication.AuthorizationError = AuthorizationError_1.default;
OAuth2Authentication.InternalOAuthError = InternalOAuthError_1.default;
OAuth2Authentication.StateVerificationFailure = StateVerificationFailure_1.default;
OAuth2Authentication.TokenError = TokenError_1.default;
exports.default = OAuth2Authentication;
module.exports = OAuth2Authentication;
module.exports.default = OAuth2Authentication;
//# sourceMappingURL=index.js.map