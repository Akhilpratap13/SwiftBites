"use strict";

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const crypto_1 = require("crypto");
const KEY_SIZE = 32;
const KDF_SALT = 'Keygrip';
const KDF_ITERATIONS = 100;
const HMAC_ALGORITHM = 'sha512';
const ENCRYPTION_ALGORITHM = 'aes-256-cbc';
const HMAC_LENGTH = 64;
const IV_LENGTH = 16;
class Keygrip {
    packString(payload) {
        return this.pack(new Buffer(payload, 'utf8')).toString('base64');
    }
    unpackString(data) {
        const result = this.unpack(new Buffer(data, 'base64'));
        if (result == null) return null;
        return {
            payload: result.payload.toString('utf8'),
            outdated: result.outdated
        };
    }
}
exports.Keygrip = Keygrip;
function getKey(rawKey, length, minimumInputLength) {
    if (typeof rawKey === 'string' && /^[0-9A-F]+$/i.test(rawKey)) {
        rawKey = Buffer.from(rawKey.toUpperCase(), 'hex');
    }
    if (rawKey.length < minimumInputLength) {
        throw new Error(`You cannot use keygrip with a key shorter than ` + `${minimumInputLength} bytes (i.e. ${minimumInputLength * 2} hex encoded characters). ` + `We recommend a key length of ${length} bytes. ` + `You can generate a secure key using the command: ` + `node -e "console.log(require('crypto').randomBytes(${length}).toString('hex'))"`);
    }
    // Derive context-specific keys out of raw key inputs. The user is expected to provide
    // cryptographically secure keys, so a static salt and low iteration count are
    // sufficient.
    return Buffer.isBuffer(rawKey) && rawKey.length === length ? rawKey : crypto_1.pbkdf2Sync(rawKey, KDF_SALT, KDF_ITERATIONS, length, 'sha512');
}
function getKeyAsync(rawKey, length, minimumInputLength) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof rawKey === 'string' && /^[0-9A-F]+$/i.test(rawKey)) {
            rawKey = Buffer.from(rawKey.toUpperCase(), 'hex');
        }
        if (rawKey.length < minimumInputLength) {
            throw new Error(`You cannot use keygrip with a key shorter than ` + `${minimumInputLength} bytes (i.e. ${minimumInputLength * 2} hex encoded characters). ` + `We recommend a key length of ${length} bytes. ` + `You can generate a secure key using the command: ` + `node -e "console.log(require('crypto').randomBytes(${length}).toString('hex'))"`);
        }
        // Derive context-specific keys out of raw key inputs. The user is expected to provide
        // cryptographically secure keys, so a static salt and low iteration count are
        // sufficient.
        return Buffer.isBuffer(rawKey) && rawKey.length === length ? rawKey : yield new Promise((resolve, reject) => {
            crypto_1.pbkdf2(rawKey, KDF_SALT, KDF_ITERATIONS, length, 'sha512', (err, derivedkey) => {
                if (err) reject(err);else resolve(derivedkey);
            });
        });
    });
}
class KeygripSecret extends Keygrip {
    constructor(keys) {
        super();
        this._keys = keys.map(rawKey => {
            // Derive context-specific keys out of raw key inputs. The user is expected to provide
            // cryptographically secure keys, so a static salt and low iteration count are
            // sufficient.
            const key = getKey(rawKey, KeygripSecret.RECOMMENDED_KEY_LENGTH, KeygripSecret.MINIMUM_KEY_LENGTH);
            return {
                encrypt: key.slice(0, KEY_SIZE),
                hmac: key.slice(KEY_SIZE, KEY_SIZE * 2)
            };
        });
    }
    static createAsync(keys) {
        return Promise.all(keys.map(key => getKeyAsync(key, KeygripSecret.RECOMMENDED_KEY_LENGTH, KeygripSecret.MINIMUM_KEY_LENGTH))).then(keys => new KeygripSecret(keys));
    }
    encrypt(payload) {
        const key = this._keys[0];
        const iv = crypto_1.randomBytes(16);
        const cipher = crypto_1.createCipheriv(ENCRYPTION_ALGORITHM, key.encrypt, iv);
        const ciphertext = Buffer.concat([cipher.update(payload), cipher.final()]);
        const mac = crypto_1.createHmac(HMAC_ALGORITHM, key.hmac).update(iv).update(ciphertext).digest();
        assert(mac.length === HMAC_LENGTH, `Expected hmac length to be ${HMAC_LENGTH}`);
        assert(iv.length === IV_LENGTH, `Expected iv length to be ${IV_LENGTH}`);
        assert(ciphertext.length >= 16, 'Expected ciphertext length to be at least 16');
        return Buffer.concat([mac, iv, ciphertext]);
    }
    tryDecrypt(data, keyIndex) {
        if (keyIndex === undefined) {
            for (let i = 0; i < this._keys.length; i++) {
                const message = this.tryDecrypt(data, i);
                if (message !== null) return message;
            }
            return null;
        }
        const key = this._keys[keyIndex];
        if (!key) {
            throw new Error('Invalid key index ' + keyIndex);
        }
        if (data.length < HMAC_LENGTH + IV_LENGTH) return null;
        const mac = data.slice(0, HMAC_LENGTH);
        const iv = data.slice(HMAC_LENGTH, HMAC_LENGTH + IV_LENGTH);
        const ciphertext = data.slice(HMAC_LENGTH + IV_LENGTH, data.length);
        const actualMac = crypto_1.createHmac(HMAC_ALGORITHM, key.hmac).update(iv).update(ciphertext).digest();
        if (!crypto_1.timingSafeEqual(mac, actualMac)) {
            return null;
        }
        const cipher = crypto_1.createDecipheriv(ENCRYPTION_ALGORITHM, key.encrypt, iv);
        return {
            payload: Buffer.concat([cipher.update(ciphertext), cipher.final()]),
            outdated: keyIndex !== 0
        };
    }
    pack(payload) {
        return this.encrypt(payload);
    }
    unpack(data) {
        return this.tryDecrypt(data);
    }
}
KeygripSecret.RECOMMENDED_KEY_LENGTH = KEY_SIZE * 2;
KeygripSecret.MINIMUM_KEY_LENGTH = 8;
exports.KeygripSecret = KeygripSecret;
class KeygripPublic extends Keygrip {
    constructor(keys) {
        super();
        this._keys = keys.map(rawKey => {
            // Derive context-specific keys out of raw key inputs. The user is expected to provide
            // cryptographically secure keys, so a static salt and low iteration count are
            // sufficient.
            return getKey(rawKey, KeygripPublic.RECOMMENDED_KEY_LENGTH, KeygripPublic.MINIMUM_KEY_LENGTH);
        });
    }
    static createAsync(keys) {
        return Promise.all(keys.map(key => getKeyAsync(key, KeygripPublic.RECOMMENDED_KEY_LENGTH, KeygripPublic.MINIMUM_KEY_LENGTH))).then(keys => new KeygripPublic(keys));
    }
    sign(payload) {
        const key = this._keys[0];
        const mac = crypto_1.createHmac(HMAC_ALGORITHM, key).update(payload).digest();
        assert(mac.length === HMAC_LENGTH, `Expected hmac length to be ${HMAC_LENGTH}`);
        return Buffer.concat([mac, payload]);
    }
    tryVerify(data, keyIndex) {
        if (keyIndex === undefined) {
            for (let i = 0; i < this._keys.length; i++) {
                const message = this.tryVerify(data, i);
                if (message !== null) return message;
            }
            return null;
        }
        const key = this._keys[keyIndex];
        if (!key) {
            throw new Error('Invalid key index ' + keyIndex);
        }
        if (data.length < HMAC_LENGTH) return null;
        const mac = data.slice(0, HMAC_LENGTH);
        const payload = data.slice(HMAC_LENGTH, data.length);
        const actualMac = crypto_1.createHmac(HMAC_ALGORITHM, key).update(data).digest();
        if (!crypto_1.timingSafeEqual(mac, actualMac)) {
            return null;
        }
        return { payload, outdated: keyIndex !== 0 };
    }
    pack(payload) {
        return this.sign(payload);
    }
    unpack(data) {
        return this.tryVerify(data);
    }
}
KeygripPublic.RECOMMENDED_KEY_LENGTH = KEY_SIZE;
KeygripPublic.MINIMUM_KEY_LENGTH = 8;
exports.KeygripPublic = KeygripPublic;
class KeygripPassThrough extends Keygrip {
    pack(payload) {
        return payload;
    }
    unpack(data) {
        return { payload: data, outdated: false };
    }
}
exports.KeygripPassThrough = KeygripPassThrough;
//# sourceMappingURL=index.js.map